# CC_2026-01-08_programming-language-python

DATE: 2026-01-08
TYPE: Cognitive Checkpoint
MODE: SNAPSHOT
TOPIC: プログラミング言語観とPython学習の位置づけ

---

## 1. 現在の認識（結論ではない）

* 自分は
  **オブジェクト指向・イベントドリブン中心の設計と相性が悪い**
* 思考・設計の好みは一貫して
  **処理の流れ／パイプライン／手続き型／構造化**
* AIは
  擬似人格・自律主体ではなく
  **高度なインタプリタ型の実行環境**として捉えている
* この見方により
  「AIと自分の相性問題」が顕在化しなかった

---

## 2. 背景・ここまでの流れ（必要に応じて）

* BASIC時代から
  サブルーチン化・共用・処理分離を意識していた
* GUIとCUI（コアロジック）を分離する設計が好み
* パイプライン処理・直線的フローが好き
* OOP・イベントドリブンは
  「処理の入口／出口が見えにくい」ため腑に落ちない
* AIエージェント文脈に触れたことで
  自身の設計嗜好がより明確になった

---

## 3. 現在の整理ポイント

### 言語ごとの位置づけ

* BASIC
  → 実行環境と密結合しやすく、今触ると機種依存が強く出そう
* C
  → 実行環境を「作る側」になってしまい、目的過剰
* シェル
  → 言語というよりコマンド列／オーケストレーション用途
* Ruby
  → 読みやすさはあるが、AI文脈との距離がややある
* Python
  →

  * 手続き型で書ける
  * OOPを強制しない
  * 処理の流れが目で追える
  * AI界隈の共通語
    ⇒ **中間言語／実行用の紙と鉛筆として適合**

---

## 4. 仮の位置づけ／比喩（あれば）

* YAML
  → 静的な擬似コード／設計図
* Python
  → **動的な擬似コード（そのまま動く）**
* Pythonは
  「YAMLに if / for を足したら実行できてしまった世界」
* BGNI／CC／構造アウトライン
  → 人間とAIの間の **中間言語（ANSI C 的立ち位置）**

---

## 5. 未確定点・違和感

* Pythonを
  「どこまで避けて、どこまで使うか」の線引き
* イベント・非同期・OOPを
  どこまで明示的に避けるか
* AIエージェント文脈で
  Pythonをどう最小限に関与させるか

---

## 6. 再開用フック（次に考える問い）

* 「Pythonで**やらない**ことを先に決めると、何が残るか」
* 「Pythonのエラーは、どの層で分類すると一番しっくり来るか」
* 「PythonをMakefile的に使うとは、具体的にどういう運用か」
* 「BGNI / CC 補助としてのPython最小構成は何か」

---
